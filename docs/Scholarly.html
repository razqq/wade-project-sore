<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Sore Scholarly HTML</title>
</head>
<header>
    <h1 style="color:rgb(126, 31, 126)">Sore Scholarly HTML</h1>
</header>

<body>

    <section typeof="sa:AuthorsList">
        <h3>Authors</h3>
        <ul>
            <li typeof="sa:ContributorRole" property="schema:author">
                <span typeof="schema:Person" resource="">
                    <meta property="schema:givenName" content="Iuliana">
                    <meta property="schema:additionalName" content="Iustina">
                    <meta property="schema:familyName" content="Sarbu">
                    <span property="schema:name">Sarbu Iulia Iustina</span>
                </span>
                <ul>
                    <li property="schema:roleContactPoint" typeof="schema:ContactPoint">
                        <a href="sarbu.iustina@gmail.com" property="schema:email">sarbu.iustina@gmail.com</a>
                    </li>
                </ul>
            </li>
            <li typeof="sa:ContributorRole" property="schema:author">
                <span typeof="schema:Person" resource="">
                    <meta property="schema:givenName" content="Iuliana">
                    <meta property="schema:additionalName" content="Iustina">
                    <meta property="schema:familyName" content="Sarbu">
                    <span property="schema:name">Croitoru Razvan</span>
                </span>
                <ul>
                    <li property="schema:roleContactPoint" typeof="schema:ContactPoint">
                        <a href="croitorurazvan1@gmail.com" property="schema:email">croitorurazvan1@gmail.com</a>
                    </li>
                </ul>
            </li>
        </ul>
    </section>


    <section typeof="sa:Discussion Group">
        <h5>Discussion Group</h5>
        <ul>
            <li property="schema:listDiscussionGroup" typeof="schema:DiscussionGroup">
                <a href="https://github.com/razqq/wade-project-sore" property="schema:linkDiscussionGroup">GitHub
                    Repository</a>
            </li>
        </ul>
    </section>

    <section typeof="sa:Abstract">
        <h2 style="color:rgb(126, 31, 126)">1. Abstract</h2>
        This paper describes the design and implementation of an innovative web-based recommendation system that uses a user-specific knowledge graph written in RDF (Resource Description Framework) to offer tailored suggestions. The technology collects data from individuals' social media profiles in a unique way, then tailors suggestions based on numerous aspects and attributes. It may propose a wide range of objects, such as people, events, locations, and other interests, by evaluating and synthesizing complicated data links inside the knowledge graph. The system's main design is modular, with a React-based frontend, a Node.js backend, and MongoDB for data storage, augmented by a specific graph database for managing RDF data. The design enables rapid data import, complex query processing using a SPARQL interface, and dynamic recommendation creation using machine learning techniques. The incorporation of user input acts as a method for ongoing learning and enhancement of suggestion accuracy. The system's modular architecture not only improves scalability and maintainability, but also enables independent and concurrent development of its components. This article describes the system's architecture, data flow, and how its numerous components interact, with a focus on contemporary web technologies and data processing techniques. We also explore the challenges of integrating multiple data sources, as well as the tactics used to provide a smooth, user-friendly experience. The system's success is illustrated through a variety of use cases, which emphasize its capacity to adapt to user preferences and habits, providing a highly customized user experience.
    </section>

    <section typeof="sa:Introduction">
        <h2 style="color:rgb(126, 31, 126)">2. Introduction</h2>
        The introduction of big data and advanced analytics has opened the path for the creation of systems capable of offering highly tailored information to consumers. Our recommendation system is intended to use these capabilities, providing a user-centric experience by evaluating a wide range of data sources. This study describes the fundamental data structures, the characteristics of external data sources, and the adherence to linked data standards.
    </section>

    <section typeof="sa:Structure">
        <h2 style="color:rgb(126, 31, 126)">3. Structure</h2>
        In this chapter, we look at the complicated structure of the web-based recommendation system, including the architectural components and their interrelationships. This system's architecture is painstakingly developed to enable its fundamental capability of providing individualized suggestions based on a knowledge network, assuring both scalability and resilience.
        <ol>
            <br />
            <br>
            <li property="schema: roleModularArchitecture">
                <u>Modular architecture</u>
                <br />
                <br>
                The system is built in a modular fashion, with various essential components, each responsible for a certain part of the system's operation. This modular framework facilitates development and maintenance while simultaneously increasing system scalability and performance.
                <br />
                <br>
                <ul property="schema: roleFrontendModule">
                    <u>Frontend Module</u>
                    <br />
                    <br>
                    Technology Used: -
                    <br />
                    <br>
                    Function: The frontend is the system's user interface. It is intended to be straightforward, responsive, and accessible, offering users an interactive platform to enter preferences, examine suggestions, and provide comments.
                </ul>
                <br />
                <br>
                <ul property="schema: roleBackendModule">
                    <u>Backend Module</u>
                    <br />
                    <br>
                    Technology Used: Node.js, Python
                    <br />
                    <br>
                    Function: This module serves as the system's backbone, responsible for business logic, data processing, API administration, and communication between the frontend and other system components.
                </ul>
                <br />
                <br>
                <ul property="schema: roleKnowledgeGraphStore">
                    <u> Knowledge Graph Store</u>
                    <br />
                    <br>
                    Technology Used: Neo4j
                    <br />
                    <br>
                    Function: Neo4j is a popular choice for creating knowledge graphs because of its robust graph processing capabilities, customizable schema, and rapid querying using the Cypher query language. Neo4j enables businesses to develop, browse, and exploit knowledge graphs for a variety of advanced applications by storing data in graph format and allowing complex query operations.
                </ul>
                <br />
                <br>
                <ul property="schema: roleSPARQLEndpoint">
                    <u> SPARQL Endpoint</u>
                    <br />
                    <br>
                    Technology Used: Blazegraph
                    <br />
                    <br>
                    Function: Blazegraph serves as a SPARQL endpoint, allowing customers to send SPARQL queries over HTTP and get responses in a variety of forms. This makes it a flexible and interoperable option for accessing and processing graph-structured data, particularly in dispersed and web-based settings. Its compliance with SPARQL means that it can operate seamlessly with other tools and frameworks in the semantic web ecosystem.
                </ul>
            </li>
            <br>
            <br />
            <br>
            <li property="schema: roleDataFlow">
                <u>Data Flow </u>
                <br />
                <br>
                The data flow inside the system has been optimized to guarantee efficiency and accuracy. User data is gathered from social media networks and organized into a structured way. This information is subsequently utilized to populate the knowledge graph, which is stored and controlled. The backend module retrieves and processes this data in response to user requests, and the results are shown on the frontend.
            </li>
            <br>
            <br />
            <br>
            <li property="schema: roleIntegrationandInteraction">
                <u>Integration and Interaction</u>
                <br> <br>
                The integration of multiple modules is critical to the system's operation. The backend acts as an intermediate, allowing data to flow between the frontend, database, and knowledge graph store. This contact is facilitated by well-defined APIs and communication protocols, resulting in seamless and secure data exchange.
            </li>
            <br>
            <br />
            <br>
            <li property="schema: roleScalabilityandPerformanceOptimization">
                <u>Scalability and Performance Optimization</u>
                <br> <br>
                The system is built for scalability, enabling each module to be grown separately according to demand. Performance optimization methods like as caching, load balancing, and efficient query processing are used to keep the system responsive and efficient even under heavy demand.
            </li>
            <br>
            <br />
            <br>
            <li property="schema: roleSecurityArchitecture">
                <u>Security Architecture</u>
                <br> <br>
                Security is a top priority in the system's architecture. To safeguard user data and system integrity, it uses strong authentication techniques, data encryption, secure API endpoints, and data privacy compliance.
            </li>
            <br />
            <br>
        </ol>
    </section>

    <section typeof="sa:Functionality">
        <h2 style="color:rgb(126, 31, 126)">4. Functionality</h2>
        <ol>
            <li>Frontend Module
                <br> <br>
                Technology: -
                <br>
                Functionality:
                <ul>
                    <li>User Interface: Presents a clean and interactive interface for users to input preferences, view recommendations, and provide feedback.</li>
                    <li>Data Presentation: Utilizes dynamic components to display personalized recommendations and user profiles.</li>
                    <li>User Interaction: Handles user inputs, including preferences and feedback, and communicates these to the backend for processing.</li>
                </ul>
            </li>
            <br> <br>
            <li>Backend Module
                <br> <br>
                Technology: Node.js
                <br>
                Functionality:
                <ul>
                    <li>API Management: Manages APIs for data exchange between the frontend, database, and knowledge graph.</li>
                    <li>Data Processing: Processes user data and preferences, transforming them into a format suitable for the recommendation engine.</li>
                    <li>Authentication and Security: Implements secure user authentication and data protection protocols.
                    </li>
                </ul>
            </li>
            <br> <br>
            <li>Knowledge Graph Store
                <br> <br>
                Technology: Graph Database
                <br>
                Functionality:
                <ul>
                    <li>RDF Data Management: Stores and maintains the RDF data that forms the knowledge graph.</li>
                    <li>Graph Queries: Enables complicated graph queries, which are necessary for creating tailored suggestions.</li>
                    <li>Data Relationships:  Effectively manages the relationships inside the knowledge graph, which is critical for effective recommendation logic.</li>
                </ul>
            </li>
            <br> <br>
            <li>SPARQL Endpoint
                <br> <br>
                Functionality:
                <ul>
                    <li>Query Execution: Runs SPARQL queries against the knowledge graph.</li> 
                    <li>Data Retrieval: Extracts complicated data sets from the knowledge graph as needed by the recommendation engine.</li> <li>Integration: Integrates seamlessly with the backend to deliver the data required for recommendation processing.</li>
                </ul>
            </li>
            <br> <br>
            <li>Recommendation Engine
                <br> <br>
                Functionality:
                <ul>
                    <li>The system assigns suggestions to different grades based on the user's relationship with other users or artists.
                        Grade -1: Skips artists that users in similar connections detest.
                        Grade 1: Emphasizes artists loved by other users who share the same interests as the present user (up to 50% of the maximum).
                        Grade 2: Chooses musicians favored by users in the same hometown or place as the present user (25% of the maximum).
                        Grade 3: Takes into account artists favored by users whose hometown is the present user's location, or vice versa (15% of the maximum).
                        Grade 4: Includes artists who are comparable to those favored by the user (70%), as well as random artists (30%) if no previous grades' recommendations are available.
                   </li>
                </ul>
            </li>
            <br> <br>
            <li>Feedback and Learning Module
                <br> <br>
                Functionality:
                <ul>
                    <li> The algorithm promotes relevance based on user choices and social connections (for example, friends' likes, location/job similarities).
                        Random recommendations help to strike a balance between relevance and diversity.
                        The use of grades enables a flexible and dynamic recommendation technique, with proportions adjusted based on user input.
                        The algorithm is sophisticated and may necessitate large computer resources, depending on the size of the dataset and number of users.</li>
                </ul>
            </li>
        </ol>
    </section>


    <section typeof="sa:Structure">
        <h2 style="color:rgb(126, 31, 126)">5. Internal Data Structures and Models</h2>
        <ol>
            <li>User Profiles
                <br>
                <ul>
                    <li>Structure: JSON documents with fields for user demographics, preferences, and interaction history.</li>
                </ul>
            </li>
            <br> <br>
            <li>Knowledge Graph <br> 
                <ul> 
                    <li>RDF triples express meaningful connections between entities.</li>
                     <li>Model: A graph database structure that allows for complicated queries and associations, which are required for recommendation logic.</ul>
                     </li>
                      <br> <br>
                       <li>Recommendation Data
                <br>
                <ul> 
                    <li>Structure: Aggregated and processed data utilized to provide suggestions.</li>
                     <li>Custom data models in Node.js that incorporate user profile data and knowledge graph insights.</ul> 
                    </li> <br>
        </ol>
    </section>

    <section typeof="sa:Structure">
        <h2 style="color:rgb(126, 31, 126)">6. External Data Sources</h2>
        <ol>
            <li>Social Media APIs
                <br>
                <ul>
                    <li>Sources: Facebook, Twitter, LinkedIn, etc.</li>
                    <li>Data Utilization: Fetch user-generated content, preferences, and social graphs to enrich user profiles and the knowledge graph.</li>
                </ul>
            </li>
            <br> <br>
            <li>Public Web Services
                <br>
                <ul>
                    <li>Sources: Open data portals, content aggregators.</li>
                    <li>Data Utilization: Supplement user data with broader context and additional content for comprehensive profiling.</li>
                </ul>
            </li>
        </ol>
    </section>

    <section typeof="sa:Structure">
        <h2 style="color:rgb(126, 31, 126)">7. Data Integration and Processing</h2>
        <ol>
            <li>Data Ingestion
                <br>
                <ul>
                    <li>Methodology: Automated scripts and API clients in Node.js for data extraction from external sources..</li>
                    <li>Challenges: Ensuring data consistency and integrity during ingestion and transformation.</li>
                </ul>
            </li>
            <br> <br>
            <li>Data Transformation
                <br>
                <ul>
                    <li>Process: Converting raw data into structured formats suitable for MongoDB and RDF triples for the knowledge graph.</li>
                    <li>Tools: Data processing libraries in Node.js, RDF transformation utilities.</li>
                </ul>
            </li>
        </ol>
    </section>

    <section typeof="sa:Structure">
        <h2 style="color:rgb(126, 31, 126)">8. Adherence to Linked Data Principles</h2>
        <ol>
            <li>URI Assignment
                <br>
                <ul>
                    <li>Implementation: Assigning unique URIs to entities within the knowledge graph, facilitating global identification.</li>
                </ul>
            </li>
            <br> <br>
            <li>HTTP URI Usage
                <br>
                <ul>
                    <li>Implementation: Ensuring that URIs are dereferenceable over HTTP, allowing access to information about the entity.</li>
                </ul>
            </li>
            <br> <br>
            <li>Standard Data Formats
                <br>
                <ul>
                    <li>Implementation: Utilizing RDF and SPARQL for data representation and querying, ensuring standardization and interoperability.</li>
                </ul>
            </li>
            <br> <br>
            <li>Inclusion of Links to External Data
                <br>
                <ul>
                    <li>Implementation: Embedding links within the knowledge graph to other RDF datasets, enriching the context and depth of information.</li>
                </ul>
            </li>
        </ol>
    </section>


    <section typeof="sa:ReferencesList">
        <h2 style="color:rgb(126, 31, 126)"> For future</h2>
        <p>
            User Interactions With Songs and Albums:

            Users may develop associations with songs and albums, as well as with artists. Consider qualities like as:
            Ex:LISTENS_TO represents the relationship between ex:User and ex:Song.
            ex:FAVORITES_ALBUM denotes the link between ex:User and ex:Album.
            Social interactions:

            If social connections are important, consider adding characteristics such as "FRIEND_OF" to reflect user friendships.
            ex:FOLLOWS indicates that one user follows another user (or an artist).
            User Preferences and Profile:

            Consider including additional specific characteristics regarding user preferences or profile data, such as:
            ex:PREFERRED_GENRE links ex:User and ex:Genre.
            ex:HAS_PROFILE associates ex:User with a new class ex:UserProfile, which may then have its own set of attributes for more specific information.
            Review and Rating System:

            To allow users to rate songs, artists, or albums, provide "ex:RATES" or "ex:REVIEWS" links between ex:User and ex:Song or ex:Album, along with extra properties for rating score or review text.
            Temporal Properties:

            To describe temporal characteristics of connections (e.g., when a user liked a song), you may consider modifying the ex:created property to be more particular, like ex:relationship.Depending on what it represents, it may be created or ex:contentCreated.
            Refine Existing Properties:

            Ensure that the attributes appropriately reflect the desired connections. For example, if ex:LOCATED_IN is intended to reflect a user's location, it may be better suited to a range of ex:Town or another geographical object.
            Consistency and clarity:

            Ensure that property names are explicit and consistent in format (for example, use upper or lower camel case, as in HasHometown).
            Documentation and annotations:

            To give classes and attributes human-readable names and descriptions, use the rdfs:label and rdfs:comment methods. This can significantly improve the ontology's usability and understandability.
            </p>
    </section>

     
    <section typeof="sa:ReferencesList">
        <h2 style="color:rgb(126, 31, 126)"> References</h2>
        <ul>
            <li typeof="sa:listTW" property="schema:TW">
                <span property="schema:nameReferences">Sore</span>
                </span>
                <ul>
                    <li property="schema:linkReferences" typeof="schema:References">
                        <a href="https://profs.info.uaic.ro/~busaco/teach/courses/wade/web-projects.html"
                            property="schema:link.Net">WADe projects</a>
                    </li>
                </ul>
            </li>
        </ul>
    </section>
</body>

</html>